package modele;


import java.util.ArrayList ;
import java.lang.Math ;

import modele_exceptions.DimensionException ;
import modele_exceptions.TestException;

public class DataSet extends ArrayList<Double>
{
	private static final long serialVersionUID = 1L ;
	
	public DataSet()
	{
		super() ;
	}
		
	/**************************************************************************************/
	// methodes de manipulation de vecteurs (produit scalaire, multiplication par un scalaire,
	//addition de deux vecteurs, etc...)
	
	// multiplication par un scalaire alpha : A.smultiply(alpha) <=> alpha*A
	public DataSet smultiply(double alpha)
	{
		int length = this.size() ;
		DataSet result = new DataSet() ;
		
		for(int i = 0 ; i < length ; i++)
		{
			double coeff = this.get(i) ;
			coeff = coeff*alpha ;
			
			result.add(coeff) ;
		}
		
		return result ;
	}
	
	// soustraction : A.minus(B) <=> A-B
	public DataSet minus(DataSet otherdataset) throws DimensionException
	{
		int length = this.size() ;
		int length_otherdataset = otherdataset.size() ;
		DataSet result = new DataSet() ;
		
		if(length == length_otherdataset)
		{
			for(int i = 0 ; i < length ; i++)
			{
				double a = this.get(i) ;
				double b = otherdataset.get(i) ;
				double coeff = a - b ;
				
				result.add(coeff) ;
			}
		}
		else
		{
			throw new DimensionException() ;
		}
		
		return result ;
	}
	
	// produit scalaire : A.dot(B) <=> B.dot(A) <=> (A|B)
	public double dot(DataSet otherdataset) throws DimensionException
	{
		int length = this.size() ;
		int length_otherdataset = otherdataset.size() ;
		double dotproduct = 0.0 ;
		
		if(length == length_otherdataset)
		{
			for(int i = 0 ; i < length ; i++ )
			{
				double a = this.get(i) ;
				double b = otherdataset.get(i)  ;
				
				dotproduct = dotproduct + a*b ;
			}
		}
		else
		{
			throw new DimensionException();
		}
		
		return dotproduct ;
	}
	
	// norme : A.norm() <=> ||A||
	public double norm() throws DimensionException
	{
		double normcarre = this.dot(this) ;
		return(Math.sqrt(normcarre)) ;
	}
		
	/**************************************************************************************/
	// methode de construction de vecteurs particuliers ones, stairs, salle, barman, commandes ...
	
	public static DataSet ones(int length)
	{
		DataSet constant = new DataSet() ;
		
		for(int i = 0 ; i < length ; i++)
		{
			constant.add(1.0) ;
		}
		
		return constant ;
	}
	
	public static DataSet stairs(int length)
	{
		DataSet stairs = new DataSet() ;
		
		for(int i = 0 ; i < length ; i++)
		{
			stairs.add((double) i) ;
		}
				
		return stairs ;
	}
	
	public static DataSet salle() throws TestException
	{
		BarModele barModele = new BarModele() ;
		
		// Etude sur un créneau de 10h (entre 19h00 et 5h00), soit 600 minutes. (cf def. Modele)
		int t = barModele.getTime() ;

		// Capacité du bar à accueillir ses clients. (en théorie un entier, en pratique un réel)
		double capacite = barModele.getCapaciteSalle() ;

		// On discrétise l'ensemble.
		DataSet l_IN = new DataSet() ;

		for( int k = 0 ; k < t ; k++)
		{
			l_IN.add(barModele.lambdaIN((double)k));
		}
		        
		DataSet l_OUT = new DataSet() ;

		for( int k = 0 ; k < t ; k++)
		{
		   	l_OUT.add(barModele.lambdaOUT((double)k));
		}

		/*
		 * Création du vecteur X(t) qui contiendra les nombres de personnes dans le
		 * bar aux instants k = 0, 1, ... , (t-1) .
		 */
		DataSet X = new DataSet() ;
		X.add(0.0) ;
		
		/*
	     * Le nombre X[k] de personnes dans le bar à un instant k vaut ce qu'il y avait
		 * au temps (k-1) plus ce qui rentre ( poissrnd(l_IN(k-1)) ) ce qui sort (
		 * poissrnd(l_OUT(k-1)) ). L'utilisation du max est pour forcer la
		 * positivité du résultat sans passer par une valeur absolue qui inverserait
		 * le rôle de lambdaIN et lambdaOUT.
		 */
		    
		for(int k=1 ; k<t ; k++)
		{
			System.out.println("l_IN(" + k +"-1) = " + l_IN.get(k-1));
			System.out.println("l_OUT(" + k +"-1) = " + l_OUT.get(k-1));
		  	X.add(  Math.min(capacite, Math.max(0,X.get(k-1) + Alea.randomPoisson(l_IN.get(k-1)) - Alea.randomPoisson(l_OUT.get(k-1))))  ) ;
		}
		    
		return X ;
	}
	
	public static DataSet barman(DataSet X) throws TestException
	{
		// X : nombre de clients dans le bar.

		BarModele barModele = new BarModele() ;
		
		// Etude sur un créneau de 10h (entre 19h00 et 5h00), soit 600 minutes.
		int t = barModele.getTime() ;

		// Capacité du bar à servir ses clients.
		int capacite = barModele.getCapaciteBarman() ;

		// On discrétise. 
		DataSet l_Barman = new DataSet() ;

		for( int k = 0 ; k < t ; k++)
		{
			l_Barman.add(barModele.lambdaBarman((double)k));
		}

		/*
		 * Création du vecteur x(t) qui contiendra les nombres de commandes passées
		 * dans le bar aux instants k = 0, 1, ... , (t-1) .
		 */
				
		DataSet x = new DataSet() ;
		x.add(0.0) ;
				    
		/*
		 * Le nombre x[k] ne peut déjà pas être plus grand que le nombre de
		 * personnes dans la salle un instant plus tôt : ce qui explique la présence
		 * du min. Ensuite le nombre de commandes est proportionnel au nombre de
		 * personnes dans le bar un instant plus tôt.
		 */
		
		for(int k = 1 ; k<t ; k++)
		{
		   	x.add(  Math.min(Math.min(capacite, X.get(k-1)), Alea.randomPoisson(l_Barman.get(k-1)* X.get(k-1)))  );
		}     
				        
		return x ;
	}
	
	/**************************************************************************************/
	// methode moindrecarre
	
	public ArrayList<Double> moindrecarre() throws DimensionException
	{
		ArrayList<Double> Y = new ArrayList<Double>(2) ;
		
		int length = this.size() ;
				
		DataSet A = DataSet.stairs(length) ; 
		DataSet B = DataSet.ones(length) ;
		double nB = B.norm() ;
		
		/*
		 * L'idée est de trouver des coefficients a et b pour minimiser Sum(|X(t)-(at + b)|^2)
		 * Cela revient donc à trouver la projection orthogonale de [X(0) X(1) ...
		 * X(t-1)] sur le plan engendré par A et B (cf. ci-dessus)
		 *
		 * Un petit coup de Gram-Schmidt :
		 */
		
		DataSet B1 = B.smultiply(1/nB) ;
				
		double d = A.dot(B1) ;
		DataSet A0 = A.minus(B1.smultiply(d)) ;
		double nA0 = A0.norm() ;
		DataSet A1 = A0.smultiply(1/nA0) ;
		
		// (A1,B1) est une base orthonormée du plan engendré par (A,B). 
		
		double a1 = this.dot(A1) ;
		double b1 = this.dot(B1) ;
		
		/*
		 * Y= [a1 b1] est exprimé dans la base (A1,B1) i.e Y = a1.A1 + b1.B1
		 * Ne reste plus qu'à retourner les coefficients recherchés :
		 */
		
		Y.add(a1/nA0) ;
		Y.add(b1/nB - d*a1/(nB*nA0)) ;
		
		return Y ;
	}
}
